{"version":3,"names":["isInType","path","parent","type","parentPath","findParent","exportKind","GLOBAL_TYPES","WeakMap","NEEDS_EXPLICIT_ESM","PARSED_PARAMS","WeakSet","isGlobalType","scope","name","hasBinding","get","has","console","warn","registerGlobalType","programScope","add","safeRemove","ids","getBindingIdentifiers","Object","keys","binding","getBinding","identifier","removeBinding","opts","noScope","remove","declare","api","assertVersion","JSX_PRAGMA_REGEX","allowNamespaces","jsxPragma","jsxPragmaFrag","onlyRemoveTypeImports","optimizeConstEnums","allowDeclareFields","classMemberVisitors","field","node","buildCodeFrameError","value","decorators","definite","t","isClassPrivateProperty","accessibility","abstract","readonly","optional","typeAnnotation","override","method","constructor","classPath","assigns","paramPath","param","parameter","id","isIdentifier","isAssignmentPattern","left","push","template","statement","ast","cloneNode","replaceWith","registerBinding","injectInitialization","inherits","syntaxTypeScript","visitor","Pattern","visitPattern","Identifier","RestElement","Program","enter","state","file","fileJsxPragma","fileJsxPragmaFrag","set","Set","comments","comment","jsxMatches","exec","pragmaImportName","split","pragmaFragImportName","stmt","isImportDeclaration","program","importKind","specifier","specifiers","local","importsToRemove","specifiersLength","length","isAllSpecifiersElided","size","isImportTypeOnly","programPath","importPath","isExportDeclaration","isVariableDeclaration","isTSTypeAliasDeclaration","isTSDeclareFunction","isTSInterfaceDeclaration","isClassDeclaration","isTSEnumDeclaration","isTSModuleDeclaration","exit","sourceType","pushContainer","exportNamedDeclaration","ExportNamedDeclaration","source","every","isExportSpecifier","ExportSpecifier","ExportDefaultDeclaration","declaration","TSDeclareFunction","TSDeclareMethod","VariableDeclaration","VariableDeclarator","TSIndexSignature","ClassDeclaration","Class","typeParameters","superTypeParameters","implements","forEach","child","isClassMethod","isClassPrivateMethod","kind","isClassProperty","Function","returnType","params","shift","TSModuleDeclaration","transpileNamespace","TSInterfaceDeclaration","TSTypeAliasDeclaration","TSEnumDeclaration","const","transpileConstEnum","transpileEnum","TSImportEqualsDeclaration","isTSExternalModuleReference","moduleReference","expression","variableDeclaration","variableDeclarator","entityNameToExpr","TSExportAssignment","TSTypeAssertion","TSAsExpression","isTSAsExpression","types","tsInstantiationExpression","CallExpression","OptionalCallExpression","NewExpression","JSXOpeningElement","TaggedTemplateExpression","isTSQualifiedName","memberExpression","right","referencePaths","sourceFileHasJsx","traverse","stop"],"sources":["../src/index.ts"],"sourcesContent":["import { declare } from \"@babel/helper-plugin-utils\";\nimport syntaxTypeScript from \"@babel/plugin-syntax-typescript\";\nimport { types as t, template } from \"@babel/core\";\nimport { injectInitialization } from \"@babel/helper-create-class-features-plugin\";\nimport type { Binding, NodePath, Scope } from \"@babel/traverse\";\nimport type { Options as SyntaxOptions } from \"@babel/plugin-syntax-typescript\";\n\nimport transpileConstEnum from \"./const-enum\";\nimport type { NodePathConstEnum } from \"./const-enum\";\nimport transpileEnum from \"./enum\";\nimport transpileNamespace from \"./namespace\";\n\nfunction isInType(path: NodePath) {\n  switch (path.parent.type) {\n    case \"TSTypeReference\":\n    case \"TSExpressionWithTypeArguments\":\n    case \"TSTypeQuery\":\n      return true;\n    case \"TSQualifiedName\":\n      return (\n        // `import foo = ns.bar` is transformed to `var foo = ns.bar` and should not be removed\n        path.parentPath.findParent(path => path.type !== \"TSQualifiedName\")\n          .type !== \"TSImportEqualsDeclaration\"\n      );\n    case \"ExportSpecifier\":\n      return (\n        // @ts-expect-error: DeclareExportDeclaration does not have `exportKind`\n        (path.parentPath as NodePath<t.ExportSpecifier>).parent.exportKind ===\n        \"type\"\n      );\n    default:\n      return false;\n  }\n}\n\nconst GLOBAL_TYPES = new WeakMap<Scope, Set<string>>();\n// Track programs which contain imports/exports of values, so that we can include\n// empty exports for programs that do not, but were parsed as modules. This allows\n// tools to infer unambiguously that results are ESM.\nconst NEEDS_EXPLICIT_ESM = new WeakMap();\nconst PARSED_PARAMS = new WeakSet();\n\nfunction isGlobalType({ scope }: NodePath, name: string) {\n  if (scope.hasBinding(name)) return false;\n  if (GLOBAL_TYPES.get(scope).has(name)) return true;\n\n  console.warn(\n    `The exported identifier \"${name}\" is not declared in Babel's scope tracker\\n` +\n      `as a JavaScript value binding, and \"@babel/plugin-transform-typescript\"\\n` +\n      `never encountered it as a TypeScript type declaration.\\n` +\n      `It will be treated as a JavaScript value.\\n\\n` +\n      `This problem is likely caused by another plugin injecting\\n` +\n      `\"${name}\" without registering it in the scope tracker. If you are the author\\n` +\n      ` of that plugin, please use \"scope.registerDeclaration(declarationPath)\".`,\n  );\n\n  return false;\n}\n\nfunction registerGlobalType(programScope: Scope, name: string) {\n  GLOBAL_TYPES.get(programScope).add(name);\n}\n\n// A hack to avoid removing the impl Binding when we remove the declare NodePath\nfunction safeRemove(path: NodePath) {\n  const ids = path.getBindingIdentifiers();\n  for (const name of Object.keys(ids)) {\n    const binding = path.scope.getBinding(name);\n    if (binding && binding.identifier === ids[name]) {\n      binding.scope.removeBinding(name);\n    }\n  }\n  path.opts.noScope = true;\n  path.remove();\n  path.opts.noScope = false;\n}\n\nexport interface Options extends SyntaxOptions {\n  /** @default true */\n  allowNamespaces?: boolean;\n  /** @default \"React.createElement\" */\n  jsxPragma?: string;\n  /** @default \"React.Fragment\" */\n  jsxPragmaFrag?: string;\n  onlyRemoveTypeImports?: boolean;\n  optimizeConstEnums?: boolean;\n  allowDeclareFields?: boolean;\n}\n\ntype ExtraNodeProps = {\n  declare?: unknown;\n  accessibility?: unknown;\n  abstract?: unknown;\n  optional?: unknown;\n  override?: unknown;\n};\n\nexport default declare((api, opts: Options) => {\n  api.assertVersion(7);\n\n  const JSX_PRAGMA_REGEX = /\\*?\\s*@jsx((?:Frag)?)\\s+([^\\s]+)/;\n\n  const {\n    allowNamespaces = true,\n    jsxPragma = \"React.createElement\",\n    jsxPragmaFrag = \"React.Fragment\",\n    onlyRemoveTypeImports = false,\n    optimizeConstEnums = false,\n  } = opts;\n\n  if (!process.env.BABEL_8_BREAKING) {\n    // eslint-disable-next-line no-var\n    var { allowDeclareFields = false } = opts;\n  }\n\n  const classMemberVisitors = {\n    field(\n      path: NodePath<\n        (t.ClassPrivateProperty | t.ClassProperty) & ExtraNodeProps\n      >,\n    ) {\n      const { node } = path;\n\n      if (!process.env.BABEL_8_BREAKING) {\n        if (!allowDeclareFields && node.declare) {\n          throw path.buildCodeFrameError(\n            `The 'declare' modifier is only allowed when the 'allowDeclareFields' option of ` +\n              `@babel/plugin-transform-typescript or @babel/preset-typescript is enabled.`,\n          );\n        }\n      }\n      if (node.declare) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Fields with the 'declare' modifier cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!node.decorators) {\n          path.remove();\n        }\n      } else if (node.definite) {\n        if (node.value) {\n          throw path.buildCodeFrameError(\n            `Definitely assigned fields cannot be initialized here, but only in the constructor`,\n          );\n        }\n        if (!process.env.BABEL_8_BREAKING) {\n          // keep the definitely assigned fields only when `allowDeclareFields` (equivalent of\n          // Typescript's `useDefineForClassFields`) is true\n          if (\n            !allowDeclareFields &&\n            !node.decorators &&\n            !t.isClassPrivateProperty(node)\n          ) {\n            path.remove();\n          }\n        }\n      } else if (!process.env.BABEL_8_BREAKING) {\n        if (\n          !allowDeclareFields &&\n          !node.value &&\n          !node.decorators &&\n          !t.isClassPrivateProperty(node)\n        ) {\n          path.remove();\n        }\n      }\n\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.readonly) node.readonly = null;\n      if (node.optional) node.optional = null;\n      if (node.typeAnnotation) node.typeAnnotation = null;\n      if (node.definite) node.definite = null;\n      if (node.declare) node.declare = null;\n      if (node.override) node.override = null;\n    },\n    method({ node }: NodePath<t.ClassMethod | t.ClassPrivateMethod>) {\n      if (node.accessibility) node.accessibility = null;\n      if (node.abstract) node.abstract = null;\n      if (node.optional) node.optional = null;\n      if (node.override) node.override = null;\n\n      // Rest handled by Function visitor\n    },\n    constructor(path: NodePath<t.ClassMethod>, classPath: NodePath<t.Class>) {\n      if (path.node.accessibility) path.node.accessibility = null;\n      // Collects parameter properties so that we can add an assignment\n      // for each of them in the constructor body\n      //\n      // We use a WeakSet to ensure an assignment for a parameter\n      // property is only added once. This is necessary for cases like\n      // using `transform-classes`, which causes this visitor to run\n      // twice.\n      const assigns = [];\n      const { scope } = path;\n      for (const paramPath of path.get(\"params\")) {\n        const param = paramPath.node;\n        if (param.type === \"TSParameterProperty\") {\n          const parameter = param.parameter;\n          if (PARSED_PARAMS.has(parameter)) continue;\n          PARSED_PARAMS.add(parameter);\n          let id;\n          if (t.isIdentifier(parameter)) {\n            id = parameter;\n          } else if (\n            t.isAssignmentPattern(parameter) &&\n            t.isIdentifier(parameter.left)\n          ) {\n            id = parameter.left;\n          } else {\n            throw paramPath.buildCodeFrameError(\n              \"Parameter properties can not be destructuring patterns.\",\n            );\n          }\n          assigns.push(template.statement.ast`\n          this.${t.cloneNode(id)} = ${t.cloneNode(id)}`);\n\n          paramPath.replaceWith(paramPath.get(\"parameter\"));\n          scope.registerBinding(\"param\", paramPath);\n        }\n      }\n      injectInitialization(classPath, path, assigns);\n    },\n  };\n\n  return {\n    name: \"transform-typescript\",\n    inherits: syntaxTypeScript,\n\n    visitor: {\n      //\"Pattern\" alias doesn't include Identifier or RestElement.\n      Pattern: visitPattern,\n      Identifier: visitPattern,\n      RestElement: visitPattern,\n\n      Program: {\n        enter(path, state) {\n          const { file } = state;\n          let fileJsxPragma = null;\n          let fileJsxPragmaFrag = null;\n          const programScope = path.scope;\n\n          if (!GLOBAL_TYPES.has(programScope)) {\n            GLOBAL_TYPES.set(programScope, new Set());\n          }\n\n          if (file.ast.comments) {\n            for (const comment of file.ast.comments) {\n              const jsxMatches = JSX_PRAGMA_REGEX.exec(comment.value);\n              if (jsxMatches) {\n                if (jsxMatches[1]) {\n                  // isFragment\n                  fileJsxPragmaFrag = jsxMatches[2];\n                } else {\n                  fileJsxPragma = jsxMatches[2];\n                }\n              }\n            }\n          }\n\n          let pragmaImportName = fileJsxPragma || jsxPragma;\n          if (pragmaImportName) {\n            [pragmaImportName] = pragmaImportName.split(\".\");\n          }\n\n          let pragmaFragImportName = fileJsxPragmaFrag || jsxPragmaFrag;\n          if (pragmaFragImportName) {\n            [pragmaFragImportName] = pragmaFragImportName.split(\".\");\n          }\n\n          // remove type imports\n          for (let stmt of path.get(\"body\")) {\n            if (stmt.isImportDeclaration()) {\n              if (!NEEDS_EXPLICIT_ESM.has(state.file.ast.program)) {\n                NEEDS_EXPLICIT_ESM.set(state.file.ast.program, true);\n              }\n\n              if (stmt.node.importKind === \"type\") {\n                for (const specifier of stmt.node.specifiers) {\n                  registerGlobalType(programScope, specifier.local.name);\n                }\n                stmt.remove();\n                continue;\n              }\n\n              const importsToRemove: Set<NodePath<t.Node>> = new Set();\n              const specifiersLength = stmt.node.specifiers.length;\n              const isAllSpecifiersElided = () =>\n                specifiersLength > 0 &&\n                specifiersLength === importsToRemove.size;\n\n              for (const specifier of stmt.node.specifiers) {\n                if (\n                  specifier.type === \"ImportSpecifier\" &&\n                  specifier.importKind === \"type\"\n                ) {\n                  registerGlobalType(programScope, specifier.local.name);\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n                  if (binding) {\n                    importsToRemove.add(binding.path);\n                  }\n                }\n              }\n\n              // If onlyRemoveTypeImports is `true`, only remove type-only imports\n              // and exports introduced in TypeScript 3.8.\n              if (onlyRemoveTypeImports) {\n                NEEDS_EXPLICIT_ESM.set(path.node, false);\n              } else {\n                // Note: this will allow both `import { } from \"m\"` and `import \"m\";`.\n                // In TypeScript, the former would be elided.\n                if (stmt.node.specifiers.length === 0) {\n                  NEEDS_EXPLICIT_ESM.set(path.node, false);\n                  continue;\n                }\n\n                for (const specifier of stmt.node.specifiers) {\n                  const binding = stmt.scope.getBinding(specifier.local.name);\n\n                  // The binding may not exist if the import node was explicitly\n                  // injected by another plugin. Currently core does not do a good job\n                  // of keeping scope bindings synchronized with the AST. For now we\n                  // just bail if there is no binding, since chances are good that if\n                  // the import statement was injected then it wasn't a typescript type\n                  // import anyway.\n                  if (binding && !importsToRemove.has(binding.path)) {\n                    if (\n                      isImportTypeOnly({\n                        binding,\n                        programPath: path,\n                        pragmaImportName,\n                        pragmaFragImportName,\n                      })\n                    ) {\n                      importsToRemove.add(binding.path);\n                    } else {\n                      NEEDS_EXPLICIT_ESM.set(path.node, false);\n                    }\n                  }\n                }\n              }\n\n              if (isAllSpecifiersElided()) {\n                stmt.remove();\n              } else {\n                for (const importPath of importsToRemove) {\n                  importPath.remove();\n                }\n              }\n\n              continue;\n            }\n\n            if (stmt.isExportDeclaration()) {\n              